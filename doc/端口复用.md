要实现基于端口复用的多进程热更新，核心是让新旧进程能同时监听 同一个端口（通过 `SO_REUSEPORT` 选项），并通过信号控制进程平滑切换。以下是针对你的 Go 代码的改造方案：


### 关键改造点
1. **设置 `SO_REUSEPORT` 选项**：允许多个进程绑定同一端口。
2. **手动创建监听器（Listener）**：替代 `server.ListenAndServeTLS` 自动创建的监听器，以便配置端口复用。
3. **信号处理**：通过信号（如 `SIGUSR2` 启动新进程、`SIGTERM` 优雅旧进程）实现热更新触发。
4. **平滑退出**：旧进程收到退出信号后，停止接收新请求，处理完现有请求后退出。


### 改造后的代码
```go
package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"your_project/core"   // 替换为实际包路径
	"your_project/handler" // 替换为实际包路径
	"your_project/ws"      // 替换为实际包路径
	"github.com/gin-gonic/gin"
)

func startServer() {
	router := gin.Default()

	// 加载HTML和静态文件（保持不变）
	router.LoadHTMLGlob("page/*.html")
	router.Static("/js", "./js")
	mapHTMLFiles(router, "page") // 假设已实现

	// 路由注册（保持不变）
	router.GET("/index", Index)
	router.GET("/", Index)
	router.GET("/ws", ws.HandleWebSocket)
	router.GET("/filestore/:filename", handler.FileDownloadExHandler)

	// 配置服务器地址
	ip := core.Globals.Config.Server.Host
	port := core.Globals.Config.Server.Port
	host := fmt.Sprintf("%s:%d", ip, port)
	fmt.Printf("Server starting on %s...\n", host)

	// 1. 创建支持端口复用的监听器（关键：SO_REUSEPORT）
	listener, err := createReusableListener(host)
	if err != nil {
		core.Globals.Logger.Fatal("Failed to create listener:", err)
	}

	// 2. 配置TLS（如果需要HTTPS）
	tlsConfig := &tls.Config{
		InsecureSkipVerify: true, // 仅测试用，生产环境需关闭
		GetCertificate: func(info *tls.ClientHelloInfo) (*tls.Certificate, error) {
			// 加载证书（支持热更新证书时可在此处动态读取）
			cert, err := tls.LoadX509KeyPair(
				core.Globals.Config.Server.CertFile,
				core.Globals.Config.Server.KeyFile,
			)
			return &cert, err
		},
	}

	// 3. 包装监听器为TLS监听器（如果用HTTP则无需此步）
	tlsListener := tls.NewListener(listener, tlsConfig)

	// 4. 创建HTTP服务器
	server := &http.Server{
		Addr:    host,
		Handler: router,
	}

	// 5. 信号处理：实现热更新和优雅退出
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT, syscall.SIGUSR2)

	// 启动服务器（非阻塞）
	go func() {
		core.Globals.Logger.Info("Server started successfully")
		if err := server.Serve(tlsListener); err != nil && err != http.ErrServerClosed {
			core.Globals.Logger.Fatal("Server exited unexpectedly:", err)
		}
	}()

	// 等待信号
	sig := <-sigChan
	switch sig {
	case syscall.SIGUSR2:
		// 收到SIGUSR2：启动新进程（热更新）
		core.Globals.Logger.Info("Received SIGUSR2, starting new process...")
		startNewProcess()
		// 旧进程继续运行，等待后续退出信号
	case syscall.SIGTERM, syscall.SIGINT:
		// 收到退出信号：优雅关闭
		core.Globals.Logger.Info("Received exit signal, shutting down gracefully...")
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		if err := server.Shutdown(ctx); err != nil {
			core.Globals.Logger.Error("Server shutdown failed:", err)
		} else {
			core.Globals.Logger.Info("Server exited gracefully")
		}
	}
}

// createReusableListener 创建支持SO_REUSEPORT的监听器
func createReusableListener(addr string) (net.Listener, error) {
	// 解析地址获取网络类型（tcp4/tcp6）
	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return nil, err
	}

	// 创建原始TCP监听器
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		return nil, err
	}

	// 设置SO_REUSEPORT选项（关键：允许端口复用）
	// 注意：Windows不支持SO_REUSEPORT，仅Linux/macOS有效
	file, err := listener.File() // 获取监听器的文件描述符
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// 设置SO_REUSEPORT（需要syscall包支持）
	if err := syscall.SetsockoptInt(int(file.Fd()), syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1); err != nil {
		return nil, fmt.Errorf("failed to set SO_REUSEPORT: %v", err)
	}

	// 基于文件描述符重新创建监听器（确保选项生效）
	newListener, err := net.FileListener(file)
	if err != nil {
		return nil, err
	}
	return newListener, nil
}

// startNewProcess 启动新进程（复用当前进程的参数）
func startNewProcess() error {
	// 获取当前进程的启动参数
	args := os.Args
	env := os.Environ()

	// 启动新进程（替换为你的可执行文件路径，通常是os.Args[0]）
	cmd := &exec.Cmd{
		Path:   args[0],
		Args:   args,
		Env:    env,
		Stdin:  os.Stdin,
		Stdout: os.Stdout,
		Stderr: os.Stderr,
	}

	return cmd.Start()
}

// 占位：原有的Index函数
func Index(c *gin.Context) {
	c.HTML(http.StatusOK, "index.html", nil)
}

// 占位：原有的mapHTMLFiles函数（保持不变）
func mapHTMLFiles(router *gin.Engine, dir string) {
	// 你的实现...
}
```


### 热更新流程说明
1. **启动初始进程**：
   ```bash
   ./your_server  # 启动第一个进程，监听端口（如7817）
   ```

2. **发布新版本**：
   将新的可执行文件替换旧文件（建议先备份，方便回滚）。

3. **触发热更新**：
   向旧进程发送 `SIGUSR2` 信号，启动新进程：
   ```bash
   kill -USR2 <旧进程PID>
   ```
   - 新进程启动后，会通过 `SO_REUSEPORT` 复用同一端口，开始接收新请求。
   - 此时新旧进程同时运行，内核会自动将新请求分发到两个进程（负载均衡）。

4. **停止旧进程**：
   向旧进程发送 `SIGTERM` 信号，使其优雅退出：
   ```bash
   kill -TERM <旧进程PID>
   ```
   - 旧进程收到信号后，会停止接收新请求，处理完现有请求后退出。
   - 最终只有新进程运行，完成热更新。


### 关键注意事项
1. **`SO_REUSEPORT` 兼容性**：
   - 仅支持 Linux（3.9+）、macOS（10.10+）、FreeBSD 等系统，Windows 不支持。
   - 确保编译环境的 `syscall` 包支持 `SO_REUSEPORT`（通常没问题）。

2. **无状态服务**：
   该方案适用于无状态服务（如HTTP API）。如果服务有状态（如内存缓存），需额外处理状态同步（如用共享内存、Redis等）。

3. **原子替换可执行文件**：
   更新可执行文件时，建议先写临时文件（如 `your_server.new`），再用 `mv your_server.new your_server` 原子替换，避免新进程启动时读取到不完整文件。

4. **回滚机制**：
   保留旧版本可执行文件，若新进程异常，可启动旧进程并停止新进程回滚。

5. **证书热更新**：
   代码中通过 `GetCertificate` 动态加载证书，更新证书后无需重启，新连接会自动使用新证书。


通过以上改造，你的服务可以实现不中断的热更新，新请求会平滑切换到新进程，旧进程处理完现有请求后退出。